# -*- coding: utf-8 -*-

from argparse import ArgumentParser
from collections import defaultdict
import logging
import sys
import argparse
import textwrap

from requests import exceptions
import colorlog
import yaml

from .clair import Clair
from .docker_image import Image
from .docker_registry import LocalRegistry, RemoteRegistry
from .report import SEVERITIES, WhiteList
from .__version__ import __version__


logger = logging.getLogger(__name__)


class ClairCli(object):
    description = 'Command line tool to interact with Quay Clair' \
                  ' to analyze docker image in different ways'
    epilog = '''Examples:

    # analyze and output report to html
    # clair is running at http://localhost:6060
    claircli example.reg.com/myimage1:latest example.reg.com/myimage2:latest

    # analyze image in insecure registry
    # clair is running at http://localhost:6060
    claircli -i example.reg.com example.reg.com/myimage1:latest

    # analyze and output report to html
    # clair is running at https://example.clair.com:6060
    claircli -c https://example.clair.com:6060 example.reg.com/myimage1:latest

    # analyze and output report to html, json
    claircli -f html -f json example.reg.com/myimage1:latest

    # analyze with threshold and white list
    claircli -t High -w white_list_file.yml example.reg.com/myimage1:latest

    # analyze image on local host
    claircli -l <local ip address> myimage1:latest myimage2:latest

    # analyze image on other host foo
    export DOCKER_HOST=tcp://<ip of foo>:<port of docker listen>
    claircli -l <local ip address> myimage1:latest

    # analyze with regular expression, following will match
    # example.reg.com/myimage1:latest
    # and example.reg.com/myimage2:latest
    claircli -r example.reg.com/myimage:latest

    # analyze with regular expression, following will match
    # example.reg.com/myimage1:latest only
    claircli -r example.reg.com/^myimage1$:^latest$

    # analyze an image stored in an Amazon ECR repository
    # This uses the registry token generated by the aws cli tool,
    # such as by running "aws ecr get-authorization-token
    # --output text --query 'authorizationData[].authorizationToken'"
    claircli \
        -k 123456789012.dkr.ecr.us-east-1.amazonaws.com:$MYTOKEN \
        123456789012.dkr.ecr.us-east-1.amazonaws.com/myimage:latest
    '''

    def __init__(self):
        # common options
        parser = ArgumentParser(
            description=self.description,
            formatter_class=argparse.RawDescriptionHelpFormatter,
            epilog=self.epilog)

        parser.add_argument(
            '-c', '--clair', default='http://localhost:6060',
            help='clair url, default: %(default)s')
        parser.add_argument(
            '-f', '--formats', choices=['html', 'json'],
            action='append', default=['html'],
            help='output report file with give format, default: %(default)s')
        parser.add_argument(
            '-T', '--threshold', choices=SEVERITIES,
            default='Unknown', metavar='THRESHOLD',
            help='cvd severity threshold, if any servity of vulnerability'
            ' above of threshold, will return non-zero, default: %(default)s'
            ', choices are: {}'.format(SEVERITIES))
        parser.add_argument(
            '-w', '--white-list', help='path to the whitelist file')
        group = parser.add_mutually_exclusive_group()
        group.add_argument(
            '-l', '--local-ip', help='ip address of local host')
        group.add_argument(
            '-r', '--regex', action='store_true',
            help='if set, repository and tag of images will be '
            'treated as regular expression')
        parser.add_argument(
            '-i', '--insecure-registry', action='append',
            dest='insec_regs', metavar='REGISTRY', default=[],
            help='domain of insecure registry')
        parser.add_argument(
            '-k', '--registry-token', action='append',
            dest='domain_tokens', default=[],
            help='docker registry token; in the form "domain:token"')
        parser.add_argument('-L', '--log-file', help='save log to file')
        parser.add_argument(
            '-d', '--debug', action='store_true', help='print more logs')
        parser.add_argument(
            '-V', '--version', action='version', version=__version__)
        parser.add_argument(
            'images', nargs='+', metavar='IMAGE',
            help='docker images or regular expression')
        parser.set_defaults(func=self.analyze_image)
        self.args = parser.parse_args()
        if self.args.local_ip and self.args.insec_regs:
            parser.error('argument --local-ip: not allowed with'
                         ' argument --insecure-registry')
        self.setup_logging()

    def setup_logging(self):
        logger = logging.getLogger('claircli')
        console_formatter = colorlog.ColoredFormatter(
            '%(log_color)s%(asctime)s|%(levelname)s|%(message)s')
        file_formatter = logging.Formatter(
            '%(asctime)s|%(levelname)s| %(message)s')
        stdout = colorlog.StreamHandler(sys.stdout)
        stdout.setFormatter(console_formatter)
        logger.addHandler(stdout)
        logger.setLevel(logging.INFO)
        if self.args.debug:
            logger.setLevel(logging.DEBUG)
        if self.args.log_file:
            handler = logging.FileHandler(self.args.log_file, 'w', delay=True)
            handler.setFormatter(file_formatter)
            logger.addHandler(handler)

    def resolve_images(self, images):
        result = set()
        for pattern in images:
            reg, repo, tag = Image.parse_id(pattern)
            registry = RemoteRegistry(reg)
            for name in registry.find_images(repo, tag):
                result.add(name)
        return result

    def analyze_image(self):
        args = self.args
        registry = None
        RemoteRegistry.insec_regs = set(args.insec_regs)
        if args.local_ip:
            registry = LocalRegistry(args.local_ip)
        elif args.regex:
            args.images = self.resolve_images(args.images)
        for domain_token in args.domain_tokens:
            domain_token_split = domain_token.split(':', 1)
            if (
                    len(domain_token_split) != 2 or
                    not domain_token_split[0] or
                    not domain_token_split[1]
            ):
                logger.warning(
                    'registry token value must be in the form "domain:token"' +
                    '; found "%s"', domain_token)
            else:
                RemoteRegistry.tokens[domain_token_split[0]] = {
                    '': 'Basic ' + domain_token_split[1]
                }

        clair = Clair(args.clair)
        if args.white_list:
            args.white_list = WhiteList(args.white_list)
        args.images = (Image(name, registry) for name in args.images)
        stats = defaultdict(list)
        for index, image in enumerate(args.images, start=1):
            logger.info('{:*^60}'.format(index))
            # Check whether we're examining a "fat manifest" or a regular image
            if image.images:
                logger.info('Analyzing manifest list ("fat manifest")...')
                for sub_image in image.images:
                    self._analyze_single_image(args, clair, sub_image, stats)
            else:
                self._analyze_single_image(args, clair, image, stats)

        return self.print_stats(stats)

    def _analyze_single_image(self, args, clair, image, stats):
        try:
            clair.analyze_image(image)
            report = clair.get_report(image)
            if not report:
                stats['IMAGES WERE NOT SUPPORTED'].append(image.name)
                return
            report.process_data(args.threshold, args.white_list)
            report.to_console()
            for format_ in args.formats:
                report.to(format_)
            if report.ok:
                stats['IMAGES WITHOUT DETECTED VULNERABILITIES'].append(
                    image.name)
            else:
                stats['IMAGES WITH DETECTED VULNERABILITIES'].append(
                    image.name)
        except exceptions.HTTPError as exp:
            if exp.response.status_code in [400, 404] and \
                ('Not Found for url' in str(exp) or
                    'no such image' in str(exp)):
                logger.warning('%s was not found', image)
                stats['IMAGES COULD NOT BE FOUND'].append(image.name)
            else:
                logger.warning('Could not analyze %s: Got response %d '
                               'from clair with message: %s',
                               image.name, exp.response.status_code,
                               exp.response.text)
                stats['IMAGES COULD NOT BE ANALYZED'].append(
                    image.name)
        except KeyboardInterrupt:
            logger.warning('Keyboard interrupted')
            return 2
        except Exception as exp:
            stats['IMAGES WERE ANALYZED WITH ERROR'].append(image.name)
            logger.warning(str(exp))
            logger.debug('Underlying problem:', exc_info=exp)
        finally:
            image.clean()

    def print_stats(self, stats):
        total = sum(map(len, stats.values()))
        logger.info('=' * 60)
        logger.info('{:^60}'.format(
            'CLAIR ANALYSIS REPORTS: (%d) IN TOTAL' % total))
        logger.info('=' * 60)
        exit_code = 0

        def log_func(func, key, value):
            func('%s (%d)', key, len(value))
            for element in value:
                func(element)

        for key, value in stats.items():
            if key == 'IMAGES WITHOUT DETECTED VULNERABILITIES':
                log_func(logger.info, key, value)
            else:
                log_func(logger.error, key, value)
                exit_code = 1
        return exit_code

    def run(self):
        return self.args.func()


def main():
    cli = ClairCli()
    sys.exit(cli.run())


if __name__ == '__main__':
    main()
